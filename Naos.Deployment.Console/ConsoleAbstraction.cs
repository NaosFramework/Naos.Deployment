// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ExampleDeploymentConsoleAbstraction.cs" company="Naos">
//    Copyright (c) Naos 2017. All Rights Reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Naos.Deployment.Bootstrapper source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Naos.Deployment.Console
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Management.Automation;
    using System.Security.Cryptography.X509Certificates;
    using System.Xml.Serialization;

    using CLAP;

    using Its.Configuration;
    using Its.Log.Instrumentation;

    using Naos.AWS.Core;
    using Naos.AWS.Domain;

    using Naos.Deployment.ComputingManagement;
    using Naos.Deployment.Core;
    using Naos.Deployment.Core.CertificateManagement;
    using Naos.Deployment.Domain;
    using Naos.Deployment.Tracking;
    using Naos.Logging.Domain;
    using Naos.Packaging.Domain;
    using Naos.Packaging.NuGet;
    using Naos.Recipes.Configuration.Setup;
    using Naos.Recipes.RunWithRetry;
    using Naos.Serialization.Factory;

    using OBeautifulCode.Security.Recipes;
    using OBeautifulCode.Validation.Recipes;

    using Spritely.Recipes;
    using Spritely.Redo;

    using static System.FormattableString;

    /// <summary>
    /// Deployment logic to be invoked from the console harness.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Deployer", Justification = "Spelling/name is correct.")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Like it this way.")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1053:StaticHolderTypesShouldNotHaveConstructors", Justification = "Used by CLAP.")]
    public class ConsoleAbstraction : ConsoleAbstractionBase
    {
        private static readonly object NugetAnnouncementFileLock = new object();

        /// <summary>n
        /// Gets new credentials on the computing platform provider, will be prepped such that output can be saved to a variable and passed back in for CredentialsJson parameter.
        /// </summary>
        /// <param name="location">Computing platform provider location to make the call against.</param>
        /// <param name="tokenLifespan">Life span of the credentials (in format dd:hh:mm).</param>
        /// <param name="username">Username of the credentials.</param>
        /// <param name="password">Password of the credentials.</param>
        /// <param name="virtualMfaDeviceId">Virtual MFA device id of the credentials.</param>
        /// <param name="mfaValue">Token from the MFA device to use when authenticating.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Optional environment name that will set the <see cref="Its.Configuration" /> precedence instead of the default which is reading the App.Config value.</param>
        /// <param name="escapeQuotes">Optional value indicating whether or not to escape quotes; DEFAULT is true.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "mfa", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Mfa", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "username", Justification = "Not sure why it's complaining...")]
        [Verb(Aliases = "credentials", Description = "Gets new credentials on the computing platform provider, will be prepped such that output can be saved to a variable and passed back in for CredentialsJson parameter.")]
        public static void GetNewCredentialJson(
            [Aliases("")] [Required] [Description("Computing platform provider location to make the call against.")] string location,
            [Aliases("")] [Required] [Description("Life span of the credentials (in format dd:hh:mm).")] string tokenLifespan,
            [Aliases("")] [Required] [Description("Username of the credentials.")] string username,
            [Aliases("")] [Required] [Description("Password of the credentials.")] string password,
            [Aliases("")] [Required] [Description("Virtual MFA device id of the credentials.")] string virtualMfaDeviceId,
            [Aliases("")] [Required] [Description("Token from the MFA device to use when authenticating.")] string mfaValue,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("")] [Description("Sets the Its.Configuration precedence to use specific settings.")] [DefaultValue(null)] string environment,
            [Aliases("")] [Description("Optional value indicating whether or not to escape quotes; DEFAULT is true.")] [DefaultValue(true)] bool escapeQuotes,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            var tokenLifespanTimeSpan = ParseTimeSpanFromDayHourMinuteColonDelimited(tokenLifespan);
            var retObj = ComputingInfrastructureManagerForAws.GetNewCredentials(
                location,
                tokenLifespanTimeSpan,
                username,
                password,
                virtualMfaDeviceId,
                mfaValue);

            var configFileManager = new ConfigFileManager(new[] { Config.CommonPrecedence }, Config.DefaultConfigDirectoryName, SerializerFactory.Instance.BuildSerializer(Config.ConfigFileSerializationDescription));

            var rawRet = configFileManager.SerializeConfigToFileText(retObj);

            // prep to be returned in a way that can be piped to a variable and then passed back in...
            var withoutNewLines = rawRet.Replace(Environment.NewLine, string.Empty);
            var escapedQuotes = escapeQuotes ? withoutNewLines.Replace("\"", "\\\"") : withoutNewLines;

            var ret = escapedQuotes;
            localResultAnnouncer(ret);
        }

        /// <summary>
        /// Gets the password of an instance from the provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "password", Description = "Gets the password of an instance from the provided tracker.")]
        public static void GetPassword(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Required] [Description("Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').")] string instanceName,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void GetPassword(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                instance.Named(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                var privateKey = Run.TaskUntilCompletion(tracker.GetPrivateKeyOfInstanceByIdAsync(environment, instance.Id));
                privateKey.Named(Invariant($"FailedToFindPrivateKeyByInstanceId-{instance.Id}")).Must().NotBeNull();

                var password = Run.TaskUntilCompletion(manager.GetAdministratorPasswordForInstanceAsync(instance, privateKey));
                password.Named(Invariant($"FailedToGetPasswordFor-{instance.Id}")).Must().NotBeNullNorWhiteSpace();

                localResultAnnouncer(password);
            }

            RunComputingManagerOperation(GetPassword, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the status of the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "status", Description = "Gets the status of the instance found by name in provided tracker.")]
        public static void GetInstanceStatus(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Required] [Description("Name of the instance to start (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').")] string instanceName,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void GetInstanceStatus(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                instance.Named(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                var status = Run.TaskUntilCompletion(manager.GetInstanceStatusAsync(instance.Id, instance.Location));
                status.Named(Invariant($"FailedToGetStatusFor-{instance.Id}")).Must().NotBeNull();

                localResultAnnouncer(status.ToString());
            }

            RunComputingManagerOperation(GetInstanceStatus, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the instances that are active (not terminated) from the underlying computing provider.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "query", Description = "Gets the instances that are active (not terminated) from the underlying computing provider.")]
        public static void GetActiveInstancesFromProvider(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void GetInstancesFromProvider(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instances = Run.TaskUntilCompletion(manager.GetActiveInstancesFromProviderAsync(environment));

                instances.ToList().OrderBy(_ => _.Name).ToList().ForEach(_ => localResultAnnouncer(Invariant($"{_.Id}\t{_.PrivateIpAddress}\t{_.Name}")));
            }

            RunComputingManagerOperation(GetInstancesFromProvider, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the instance names (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a') in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "list", Description = "Gets the instance names (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a') in provided tracker.")]
        public static void GetInstanceNames(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void GetInstances(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instances = Run.TaskUntilCompletion(tracker.GetAllInstanceDescriptionsAsync(environment));

                instances.ToList().ForEach(_ => localResultAnnouncer(Invariant($"{_.ComputerName}\t{_.PrivateIpAddress}")));
            }

            RunComputingManagerOperation(GetInstances, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the instances only in either tracking or computer platform.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "diff", Description = "Gets the instances only in either tracking or computer platform.")]
        public static void GetInstancesInTrackingAndNotProviderOrReverse(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void GetInstanceDifferences(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instancesInTracker = Run.TaskUntilCompletion(tracker.GetAllInstanceDescriptionsAsync(environment));
                var instancesInProvider = Run.TaskUntilCompletion(manager.GetActiveInstancesFromProviderAsync(environment));

                var instancesOnlyInTracker = instancesInTracker
                    .Where(tracked => !instancesInProvider.Any(provider => provider.PrivateIpAddress == tracked.PrivateIpAddress)).ToList();

                var instancesOnlyInProvider = instancesInProvider
                    .Where(provider => !instancesInTracker.Any(tracked => tracked.PrivateIpAddress == provider.PrivateIpAddress)).ToList();

                instancesOnlyInTracker.ForEach(_ => localResultAnnouncer(Invariant($"only-tracked\t{_.Id}\t{_.PrivateIpAddress}\t{_.Name}")));
                instancesOnlyInProvider.ForEach(_ => localResultAnnouncer(Invariant($"un-tracked\t{_.Id}\t{_.PrivateIpAddress}\t{_.Name}")));
            }

            RunComputingManagerOperation(GetInstanceDifferences, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Removes an instance from tracking that is not in the computing platform.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of instance to remove.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "retire", Description = "Gets the instances only in either tracking or computer platform.")]
        public static void RemoveTrackedInstance(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("name")] [Required] [Description("Name of instance to remove.")] string instanceName,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void RemoveTrackedInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                localResultAnnouncer(Invariant($"Removing {instanceName}."));
                var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                localResultAnnouncer(Invariant($"Found {instanceName} - {instance.PrivateIpAddress} - {instance.Name}."));
                Run.TaskUntilCompletion(manager.TerminateInstanceAsync(environment, instance.Id, instance.Location, true));
                localResultAnnouncer(Invariant($"Removed {instanceName}."));
            }

            RunComputingManagerOperation(RemoveTrackedInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Removes an instance from tracking that is not in the computing platform.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="privateIpAddressOfInstanceToRemove">IP Address of instance to remove (cannot be used with <paramref name="instanceNameOfInstanceToRemove" />).</param>
        /// <param name="instanceNameOfInstanceToRemove">Name of instance to remove (cannot be used with <paramref name="privateIpAddressOfInstanceToRemove" />).</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ip", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Ip", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "purge", Description = "Removes an instance from tracking that is not in the computing platform.")]
        public static void RemoveTrackedInstanceNotInComputingPlatform(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("ip")] [Description("IP Address of instance to remove.")] string privateIpAddressOfInstanceToRemove,
            [Aliases("name")] [Description("Name of instance to remove.")] string instanceNameOfInstanceToRemove,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            if (string.IsNullOrWhiteSpace(privateIpAddressOfInstanceToRemove) && string.IsNullOrWhiteSpace(instanceNameOfInstanceToRemove))
            {
                throw new ArgumentException(Invariant($"Must specify EITHER {nameof(privateIpAddressOfInstanceToRemove)} OR {nameof(instanceNameOfInstanceToRemove)}"));
            }

            if (!string.IsNullOrWhiteSpace(privateIpAddressOfInstanceToRemove) && !string.IsNullOrWhiteSpace(instanceNameOfInstanceToRemove))
            {
                throw new ArgumentException(Invariant($"Cannot specify BOTH {nameof(privateIpAddressOfInstanceToRemove)} OR {nameof(instanceNameOfInstanceToRemove)}"));
            }

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void RemoveTrackedInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                if (!string.IsNullOrWhiteSpace(instanceNameOfInstanceToRemove))
                {
                    var instancesInTracking = Run.TaskUntilCompletion(tracker.GetAllInstanceDescriptionsAsync(environment));
                    var trackedInstance = instancesInTracking.SingleOrDefault(
                        _ => (_.ComputerName ?? string.Empty).Equals(instanceNameOfInstanceToRemove, StringComparison.CurrentCultureIgnoreCase));
                    if (trackedInstance != null)
                    {
                        privateIpAddressOfInstanceToRemove = trackedInstance.PrivateIpAddress;
                    }
                }

                var instancesInProvider = Run.TaskUntilCompletion(manager.GetActiveInstancesFromProviderAsync(environment));
                var instanceInCloud = instancesInProvider.SingleOrDefault(
                    _ => ((_.PrivateIpAddress ?? string.Empty).Equals(privateIpAddressOfInstanceToRemove, StringComparison.CurrentCultureIgnoreCase)));

                if (instanceInCloud != null)
                {
                    throw new ArgumentException(Invariant($"IP Address provided: {privateIpAddressOfInstanceToRemove} exists in Provider; ID: {instanceInCloud.Id}, Name: {instanceInCloud.Name}"));
                }

                Run.TaskUntilCompletion(tracker.RemoveInstanceFromTracking(environment, privateIpAddressOfInstanceToRemove));
                localResultAnnouncer(Invariant($"Removed {privateIpAddressOfInstanceToRemove} from Tracking."));
            }

            RunComputingManagerOperation(RemoveTrackedInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Removes an instance from the computing platform that is not in tracking.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="systemIdOfInstanceToRemove">ID of instance to remove (ID from the computing platform).</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "kill", Description = "Removes an instance from the computing platform that is not in tracking.")]
        public static void RemoveInstanceInComputingPlatformNotTracked(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("id")] [Required] [Description("ID of instance to remove (ID from the computing platform).")] string systemIdOfInstanceToRemove,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            new { systemIdOfInstanceToRemove }.Must().NotBeNullNorWhiteSpace();

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void RemoveUntrackedInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instancesInProvider = Run.TaskUntilCompletion(manager.GetActiveInstancesFromProviderAsync(environment));

                var instanceInCloud = instancesInProvider.SingleOrDefault(
                    _ => ((_.Id ?? string.Empty).Equals(systemIdOfInstanceToRemove, StringComparison.CurrentCultureIgnoreCase)));

                if (instanceInCloud == null)
                {
                    throw new ArgumentException(Invariant($"ID provided: {systemIdOfInstanceToRemove} does NOT exist in provider."));
                }

                var instancesInTracking = Run.TaskUntilCompletion(tracker.GetAllInstanceDescriptionsAsync(environment));
                var trackedInstance = instancesInTracking.SingleOrDefault(
                    _ => (_.Id ?? string.Empty).Equals(systemIdOfInstanceToRemove, StringComparison.CurrentCultureIgnoreCase));

                if (trackedInstance != null)
                {
                    throw new ArgumentException(Invariant($"ID provided: {systemIdOfInstanceToRemove} does exist in Tracking; ID: {trackedInstance.Id}, Name: {trackedInstance.Name}"));
                }

                Run.TaskUntilCompletion(manager.TerminateInstanceAsync(environment, systemIdOfInstanceToRemove, instanceInCloud.Location, true));
                localResultAnnouncer(Invariant($"Removed {systemIdOfInstanceToRemove} from Provider."));
            }

            RunComputingManagerOperation(RemoveUntrackedInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the details of the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        /// <param name="resultAnnouncer">Optional result announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "details", Description = "Gets the details of the instance found by name in provided tracker.")]
        public static void GetInstanceDetails(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Required] [Description("Name of the instance to start (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').")] string instanceName,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> resultAnnouncer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;
            var localResultAnnouncer = resultAnnouncer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            var configFileManager = new ConfigFileManager(new[] { Config.CommonPrecedence }, Config.DefaultConfigDirectoryName, SerializerFactory.Instance.BuildSerializer(Config.ConfigFileSerializationDescription));

            void GetInstanceDetails(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                instance.Named(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                var instanceText = configFileManager.SerializeConfigToFileText(instance);

                localResultAnnouncer(instanceText);
            }

            RunComputingManagerOperation(GetInstanceDetails, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Starts a remote session instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = "This is fine.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "connect", Description = "Starts a remote session instance found by name in provided tracker.")]
        public static void ConnectToInstance(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Required] [Description("Name of the instance to start (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').")] string instanceName,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void Connect(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                using (var activity = Log.Enter(() => new { Name = instanceName }))
                {
                    activity.Trace("Starting");
                    var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                    instance.Named(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();
                    activity.Trace(Invariant($"Found instance: {instance.Id}"));

                    var privateKey = Run.TaskUntilCompletion(tracker.GetPrivateKeyOfInstanceByIdAsync(environment, instance.Id));
                    privateKey.Named(Invariant($"FailedToFindPrivateKeyByInstanceId-{instance.Id}")).Must().NotBeNull();
                    activity.Trace(Invariant($"Found key for password decryption."));

                    var address = instance.PrivateIpAddress;
                    var dnsStrategies = instance.DeployedPackages.Values.SelectMany(_ => _?.GetInitializationStrategiesOf<InitializationStrategyDnsEntry>())
                        .Where(_ => _ != null).ToList();
                    if (dnsStrategies.Any())
                    {
                        var allPrivateDnsEntries = dnsStrategies.Select(_ => _.PrivateDnsEntry).Distinct().ToList();
                        var tempAddress = allPrivateDnsEntries.First().Replace("{environment}", environment);

                        // can't deal with other tokens, use IP.
                        if (!tempAddress.Contains("{"))
                        {
                            address = tempAddress;
                        }
                    }

                    var user = "administrator";
                    var password = Run.TaskUntilCompletion(manager.GetAdministratorPasswordForInstanceAsync(instance, privateKey));
                    password.Named(Invariant($"FailedToGetPasswordFor-{instance.Id}")).Must().NotBeNullNorWhiteSpace();
                    activity.Trace(Invariant($"Found password."));

                    // Help from: https://stackoverflow.com/questions/11296819/run-mstsc-exe-with-specified-username-and-password
                    using (var cmdKeyInitProcess = new Process
                    {
                        StartInfo = new ProcessStartInfo(
                                                               Environment.ExpandEnvironmentVariables(@"%SystemRoot%\system32\cmdkey.exe"),
                                                               Invariant($"/generic:TERMSRV/{address} /user:{user} /pass:{password}"))
                        {
                            RedirectStandardOutput = true,
                            RedirectStandardError = true,
                            UseShellExecute = false,
                        },
                    })
                    {
                        cmdKeyInitProcess.Start().Named(Invariant($"{nameof(cmdKeyInitProcess)}.{nameof(cmdKeyInitProcess.Start)}-must-return-true")).Must().BeTrue();
                        cmdKeyInitProcess.WaitForExit();
                        var cmdKeyInitOutput = cmdKeyInitProcess.StandardOutput.ReadToEnd();
                        var cmdKeyInitError = cmdKeyInitProcess.StandardError.ReadToEnd();
                        var cmdKeyInitExitCode = cmdKeyInitProcess.ExitCode;
                        if (cmdKeyInitExitCode != 0)
                        {
                            var cmdKeyInitFailedMessage = Invariant($"Failed to run {nameof(cmdKeyInitProcess)}; {Environment.NewLine}Console Out: {cmdKeyInitOutput}{Environment.NewLine}Console Error: {cmdKeyInitError}");
                            throw new ApplicationFailedException(cmdKeyInitFailedMessage);
                        }

                        activity.Trace(Invariant($"Stored credentials temporarily stored using CMDKEY."));
                    }

                    var rdpProcess = new Process();
                    rdpProcess.StartInfo.FileName = Environment.ExpandEnvironmentVariables(@"%SystemRoot%\system32\mstsc.exe");
                    rdpProcess.StartInfo.Arguments = Invariant($"/v {address}");
                    rdpProcess.Start().Named(Invariant($"{nameof(rdpProcess)}.{nameof(rdpProcess.Start)}-must-return-true")).Must().BeTrue();
                    activity.Trace(Invariant($"Started MSTSC (Microsoft Terminal Services Client)."));

                    System.Threading.Thread.Sleep(TimeSpan.FromSeconds(5)); // dirty way to make sure that MSTSC launches before cleaning the credentials...

                    using (var cmdKeyCleanupProcess = new Process
                    {
                        StartInfo = new ProcessStartInfo(
                                                               Environment.ExpandEnvironmentVariables(@"%SystemRoot%\system32\cmdkey.exe"),
                                                               Invariant($"/delete:TERMSRV/{address}"))
                        {
                            RedirectStandardOutput = true,
                            RedirectStandardError = true,
                            UseShellExecute = false,
                        },
                    })
                    {
                        cmdKeyCleanupProcess.Start().Named(Invariant($"{nameof(cmdKeyCleanupProcess)}.{nameof(cmdKeyCleanupProcess.Start)}-must-return-true")).Must().BeTrue();
                        cmdKeyCleanupProcess.WaitForExit();
                        var cmdKeyCleanupOutput = cmdKeyCleanupProcess.StandardOutput.ReadToEnd();
                        var cmdKeyCleanupError = cmdKeyCleanupProcess.StandardError.ReadToEnd();
                        var cmdKeyCleanupExitCode = cmdKeyCleanupProcess.ExitCode;
                        if (cmdKeyCleanupExitCode != 0)
                        {
                            var cmdKeyCleanupFailedMessage = Invariant($"Failed to run {nameof(cmdKeyCleanupProcess)}; {Environment.NewLine}Console Out: {cmdKeyCleanupOutput}{Environment.NewLine}Console Error: {cmdKeyCleanupError}");
                            throw new ApplicationFailedException(cmdKeyCleanupFailedMessage);
                        }

                        activity.Trace(Invariant($"Removed credentials temporarily stored using CMDKEY."));
                    }

                    activity.Trace("Done - check for spawned window.");
                }
            }

            RunComputingManagerOperation(Connect, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Starts the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "start", Description = "Starts the instance found by name in provided tracker.")]
        public static void StartInstance(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Required] [Description("Name of the instance to start (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').")] string instanceName,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void StartInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                instance.Named(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                using (var activity = Log.Enter(() => new { instance.Name, instance.Id }))
                {
                    activity.Trace("Starting");
                    Run.TaskUntilCompletion(manager.TurnOnInstanceAsync(instance.Id, instance.Location));
                    activity.Trace("Running");
                }
            }

            RunComputingManagerOperation(StartInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Stops the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="force">Force the shutdown.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "stop", Description = "Stops the instance found by name in provided tracker.")]
        public static void StopInstance(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Required] [Description("Name of the instance to start (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').")] string instanceName,
            [Aliases("")] [Description("Force the shutdown.")] [DefaultValue(false)] bool force,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void StopInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                instance.Named(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                using (var activity = Log.Enter(() => new { instance.Name, instance.Id }))
                {
                    activity.Trace("Stopping");
                    Run.TaskUntilCompletion(manager.TurnOffInstanceAsync(instance.Id, instance.Location, force));
                    activity.Trace("Stopped");
                }
            }

            RunComputingManagerOperation(StopInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Stops then starts the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="force">Force the shutdown.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="announcer">Optional announcer for use by other class instead of via command line; DEFAULT is Console.Write.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "bounce", Description = "Stops then starts the instance found by name in provided tracker.")]
        public static void StopThenStartInstance(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Required] [Description("Name of the instance to start (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').")] string instanceName,
            [Aliases("")] [Description("Force the shutdown.")] [DefaultValue(false)] bool force,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] Action<string> announcer = null)
        {
            var localAnnouncer = announcer ?? Console.Write;

            CommonSetup(debug, environment, announcer: localAnnouncer);

            void StartInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                var instance = Run.TaskUntilCompletion(manager.GetInstanceDescriptionAsync(environment, instanceName));
                instance.Named(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                using (var activity = Log.Enter(() => new { instance.Name, instance.Id }))
                {
                    activity.Trace("Stopping");
                    Run.TaskUntilCompletion(manager.TurnOffInstanceAsync(instance.Id, instance.Location, force));
                    activity.Trace("Restarting");
                    Run.TaskUntilCompletion(manager.TurnOnInstanceAsync(instance.Id, instance.Location));
                    activity.Trace("Running");
                }
            }

            RunComputingManagerOperation(StartInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Runs provided operation with <see cref="ITrackComputingInfrastructure" /> and <see cref="IManageComputingInfrastructure" /> using provided configs.
        /// </summary>
        /// <param name="action">Action to run.</param>
        /// <param name="credentialsJson">Credentials to use.</param>
        /// <param name="infrastructureTrackerJson">Tracker JSON.</param>
        public static void RunComputingManagerOperation(Action<ITrackComputingInfrastructure, IManageComputingInfrastructure> action, string credentialsJson, string infrastructureTrackerJson)
        {
            new { action }.Must().NotBeNull();
            new { credentialsJson }.Must().NotBeNull();
            new { infrastructureTrackerJson }.Must().NotBeNull();

            var credentials = (CredentialContainer)Settings.Deserialize(typeof(CredentialContainer), credentialsJson);

            var infrastructureTrackerConfiguration = (InfrastructureTrackerConfigurationBase)Settings.Deserialize(typeof(InfrastructureTrackerConfigurationBase), infrastructureTrackerJson);
            var computingInfrastructureManagerSettings = Settings.Get<ComputingInfrastructureManagerSettings>();
            using (var infrastructureTracker = InfrastructureTrackerFactory.Create(infrastructureTrackerConfiguration))
            {
                using (var computingManager = new ComputingInfrastructureManagerForAws(computingInfrastructureManagerSettings, infrastructureTracker))
                {
                    computingManager.InitializeCredentials(credentials);
                    action(infrastructureTracker, computingManager);
                }
            }
        }

        /// <summary>
        /// Deploys a new instance with specified packages.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="nugetPackageRepositoryConfigurationsJson">NuGet Repository/Gallery configurations.</param>
        /// <param name="certificateRetrieverJson">Certificate retriever configuration JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="overrideDeploymentConfigJson">Optional deployment configuration to use as an override in JSON.</param>
        /// <param name="environmentCertificateName">Optional certificate name for an environment certificate saved in certificate manager being configured.</param>
        /// <param name="announcementFilePath">Optional announcement file path to write a JSON file of announcements (will overwrite if existing).</param>
        /// <param name="debugAnnouncementFilePath">Optional announcement file path to write a JSON file of debug announcements (will overwrite if existing)</param>
        /// <param name="telemetryFilePath">Optional telemetry file path to write a JSON file of certain step timings (will overwrite if existing).</param>
        /// <param name="nugetAnnouncementFilePath">Optional nuget file path to write a JSON file of output from nuget (will overwrite if existing).</param>
        /// <param name="instanceName">Optional name of the instance (one will be generated from the package list if not provided).</param>
        /// <param name="workingPath">Optional working directory for packages (default will be Temp Dir but might result in PathTooLongException).</param>
        /// <param name="packagesToDeployJson">Optional packages descriptions (with overrides) to configure the instance with.</param>
        /// <param name="deploymentAdjustmentApplicatorJson">Optional deployment adjustment strategies to use.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="logWritingSettings">Optional log processor settings for use by other class instead of via command line; DEFAULT is Settings based.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "nuget", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Like it this way.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "telemetryFilePath", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "nugetAnnouncementFilePath", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "debugAnnouncementFilePath", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "announcementFilePath", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "environmentCertificateName", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "packagesToDeployJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "instanceName", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "overrideDeploymentConfigJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "infrastructureTrackerJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "certificateRetrieverJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "nugetPackageRepositoryConfigurationJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "deploymentAdjustmentApplicatorJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "credentialsJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "workingPath", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "nuget", Justification = "Not sure why it's complaining...")]
        [Verb(Aliases = "deploy", Description = "Deploys a new instance with specified packages.")]
        public static void Deploy(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Aliases("")] [Required] [Description("NuGet Repository/Gallery configuration.")] string nugetPackageRepositoryConfigurationsJson,
            [Aliases("")] [Required] [Description("Certificate retriever configuration JSON.")] string certificateRetrieverJson,
            [Aliases("")] [Required] [Description("Configuration for tracking system of computing infrastructure.")] string infrastructureTrackerJson,
            [Aliases("")] [Description("Optional deployment configuration to use as an override in JSON.")] [DefaultValue(null)] string overrideDeploymentConfigJson,
            [Aliases("")] [Description("Optional certificate name for an environment certificate saved in certificate manager being configured.")] [DefaultValue(null)] string environmentCertificateName,
            [Aliases("")] [Description("Optional announcement file path to write a JSON file of announcements (will overwrite if existing).")] [DefaultValue(null)] string announcementFilePath,
            [Aliases("")] [Description("Optional announcement file path to write a JSON file of debug announcements (will overwrite if existing).")] [DefaultValue(null)] string debugAnnouncementFilePath,
            [Aliases("")] [Description("Optional telemetry file path to write a JSON file of certain step timings (will overwrite if existing).")] [DefaultValue(null)] string telemetryFilePath,
            [Aliases("")] [Description("Optional nuget file path to write a JSON file of output from nuget (will overwrite if existing).")] [DefaultValue(null)] string nugetAnnouncementFilePath,
            [Aliases("")] [Description("Optional name of the instance (one will be generated from the package list if not provided).")] [DefaultValue(null)] string instanceName,
            [Aliases("")] [Description("Optional working directory for packages (default will be Temp Dir but might result in PathTooLongException).")] [DefaultValue(null)] string workingPath,
            [Aliases("")] [Description("Optional packages descriptions (with overrides) to configure the instance with.")] [DefaultValue("[]")] string packagesToDeployJson,
            [Aliases("")] [Description("Optional deployment adjustment strategies to use.")] [DefaultValue("[]")] string deploymentAdjustmentApplicatorJson,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment,
            [Description("FOR INTERNAL USE ONLY.")] LogWritingSettings logWritingSettings = null)
        {
            CommonSetup(debug, environment, logWritingSettings);

            PrintArguments(
                new
                {
                    workingPath,
                    credentialsJson,
                    deploymentAdjustmentApplicatorJson,
                    nugetPackageRepositoryConfigurationsJson,
                    certificateRetrieverJson,
                    infrastructureTrackerJson,
                    overrideDeploymentConfigJson,
                    environment,
                    instanceName,
                    packagesToDeployJson,
                    environmentCertificateName,
                    announcementFilePath,
                    debugAnnouncementFilePath,
                    nugetAnnouncementFilePath,
                    telemetryFilePath,
                });

            var packagesToDeploy = (IReadOnlyCollection<PackageDescriptionWithOverrides>)Settings.Deserialize(typeof(IReadOnlyCollection<PackageDescriptionWithOverrides>), packagesToDeployJson);
            var certificateRetrieverConfiguration = (CertificateManagementConfigurationBase)Settings.Deserialize(typeof(CertificateManagementConfigurationBase), certificateRetrieverJson);
            var infrastructureTrackerConfiguration = (InfrastructureTrackerConfigurationBase)Settings.Deserialize(typeof(InfrastructureTrackerConfigurationBase), infrastructureTrackerJson);
            var deploymentAdjustmentStrategiesApplicator = (DeploymentAdjustmentStrategiesApplicator)Settings.Deserialize(typeof(DeploymentAdjustmentStrategiesApplicator), deploymentAdjustmentApplicatorJson);
            var credentials = (CredentialContainer)Settings.Deserialize(typeof(CredentialContainer), credentialsJson);

            var repoConfigs = (IReadOnlyCollection<PackageRepositoryConfiguration>)Settings.Deserialize(typeof(IReadOnlyCollection<PackageRepositoryConfiguration>), nugetPackageRepositoryConfigurationsJson);
            var overrideConfig = (DeploymentConfiguration)Settings.Deserialize(typeof(DeploymentConfiguration), overrideDeploymentConfigJson);

            var setupFactorySettings = Settings.Get<SetupStepFactorySettings>();
            var computingInfrastructureManagerSettings = Settings.Get<ComputingInfrastructureManagerSettings>();
            var defaultDeploymentConfiguration = Settings.Get<DefaultDeploymentConfiguration>();

            var certificateRetriever = CertificateManagementFactory.CreateReader(certificateRetrieverConfiguration);
            using (var infrastructureTracker = InfrastructureTrackerFactory.Create(infrastructureTrackerConfiguration))
            {
                using (var computingManager = new ComputingInfrastructureManagerForAws(computingInfrastructureManagerSettings, infrastructureTracker))
                {
                    computingManager.InitializeCredentials(credentials);
                    var tempDir = Path.GetTempPath();
                    var unzipDirPath = Path.Combine(tempDir, "Naos.Deployment.Temp");
                    if (!string.IsNullOrEmpty(workingPath))
                    {
                        unzipDirPath = workingPath;
                    }

                    if (Directory.Exists(unzipDirPath))
                    {
                        Using.LinearBackOff(TimeSpan.FromSeconds(5))
                            .WithMaxRetries(3)
                            .WithReporter(_ => Log.Write(new LogEntry(Invariant($"Retrying delete deployment working directory {unzipDirPath} due to error."), _)))
                            .Run(() => Directory.Delete(unzipDirPath, true))
                            .Now();
                    }

                    Using.LinearBackOff(TimeSpan.FromSeconds(5))
                        .WithMaxRetries(3)
                        .WithReporter(_ => Log.Write(new LogEntry(Invariant($"Retrying create deployment working directory {unzipDirPath} due to error."), _)))
                        .Run(() => Directory.CreateDirectory(unzipDirPath))
                        .Now();

                    if (File.Exists(nugetAnnouncementFilePath))
                    {
                        File.Delete(nugetAnnouncementFilePath);
                    }

                    var configFileManager = new ConfigFileManager(new[] { Config.CommonPrecedence }, Config.DefaultConfigDirectoryName, SerializerFactory.Instance.BuildSerializer(Config.ConfigFileSerializationDescription));

                    using (var packageManager = new PackageRetriever(unzipDirPath, repoConfigs, null, s => NugetAnnouncementAction(s, nugetAnnouncementFilePath)))
                    {
                        var deploymentManager = new DeploymentManager(
                            infrastructureTracker,
                            computingManager,
                            packageManager,
                            certificateRetriever,
                            defaultDeploymentConfiguration,
                            setupFactorySettings,
                            deploymentAdjustmentStrategiesApplicator,
                            computingInfrastructureManagerSettings.PackageIdsToIgnoreDuringTerminationSearch,
                            Console.WriteLine,
                            line =>
                            {
                                /* no-op */
                            },
                            unzipDirPath,
                            configFileManager,
                            environmentCertificateName,
                            announcementFilePath,
                            debugAnnouncementFilePath,
                            telemetryFilePath);

                        deploymentManager.DeployPackagesAsync(packagesToDeploy, environment, instanceName, overrideConfig).Wait();
                    }
                }
            }
        }

        /// <summary>
        /// Upload a certificate to the arcology from a file along with additional information about it as well as encrypting information.
        /// </summary>
        /// <param name="certificateWriterJson">Certificate writer configuration JSON.</param>
        /// <param name="name">Name of the certificate to load.</param>
        /// <param name="pfxFilePath">File path to the certificate to load (in PFX file format).</param>
        /// <param name="clearTextPassword">Clear text password of the certificate to load.</param>
        /// <param name="certificateSigningRequestPemEncodedFilePath">File path to Certificate Signing Request (PEM encoded).</param>
        /// <param name="encryptingCertificateThumbprint">Thumbprint of the encrypting certificate.</param>
        /// <param name="encryptingCertificateIsValid">Value indicating whether or not the encrypting certificate is valid.</param>
        /// <param name="encryptingCertificateStoreName"><see cref="StoreName"/> to find the encrypting certificate.</param>
        /// <param name="encryptingCertificateStoreLocation"><see cref="StoreLocation"/> to find the encrypting certificate.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Optional environment name that will set the <see cref="Its.Configuration" /> precedence instead of the default which is reading the App.Config value.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Pem", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Like it this way.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "certificateWriterJson", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "encryptingCertificateStoreLocation", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "encryptingCertificateStoreName", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "encryptingCertificateIsValid", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "encryptingCertificateThumbprint", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "cleanPassword", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "pfxFilePath", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", MessageId = "3", Justification = "Is validated with Must.")]
        [Verb(Aliases = "upload", Description = "Deploys a new instance with specified packages.")]
        public static void UploadCertificate(
            [Aliases("")] [Required] [Description("Certificate writer configuration JSON.")] string certificateWriterJson,
            [Aliases("")] [Required] [Description("Name of the certificate to load.")] string name,
            [Aliases("")] [Required] [Description("File path to the certificate to load (in PFX file format).")] string pfxFilePath,
            [Aliases("")] [Required] [Description("Clear text password of the certificate to load.")] string clearTextPassword,
            [Aliases("")] [DefaultValue(null)] [Description("File path to Certificate Signing Request (PEM encoded).")] string certificateSigningRequestPemEncodedFilePath,
            [Aliases("")] [Required] [Description("Thumbprint of the encrypting certificate.")] string encryptingCertificateThumbprint,
            [Aliases("")] [Required] [Description("Value indicating whether or not the encrypting certificate is valid.")] bool encryptingCertificateIsValid,
            [Aliases("")] [DefaultValue(null)] [Description("Store name to find the encrypting certificate.")] string encryptingCertificateStoreName,
            [Aliases("")] [DefaultValue(null)] [Description("Store location to find the encrypting certificate.")] string encryptingCertificateStoreLocation,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("")] [Description("Sets the Its.Configuration precedence to use specific settings.")] [DefaultValue(null)] string environment)
        {
            CommonSetup(debug, environment);

            PrintArguments(
                new
                {
                    name,
                    pfxFilePath,
                    maskedPassword = MaskString(clearTextPassword),
                    encryptingCertificateThumbprint,
                    encryptingCertificateIsValid,
                    encryptingCertificateStoreName,
                    encryptingCertificateStoreLocation,
                    certificateWriterJson,
                });

            new { name }.Must().NotBeNullNorWhiteSpace();
            new { pfxFilePath }.Must().NotBeNullNorWhiteSpace();
            new { clearTextPassword }.Must().NotBeNullNorWhiteSpace();
            new { encryptingCertificateThumbprint }.Must().NotBeNullNorWhiteSpace();

            if (!File.Exists(pfxFilePath))
            {
                throw new FileNotFoundException("Could not find specified PFX file path: " + pfxFilePath);
            }

            if (!string.IsNullOrWhiteSpace(certificateSigningRequestPemEncodedFilePath) && !File.Exists(certificateSigningRequestPemEncodedFilePath))
            {
                throw new FileNotFoundException("Could not find specified Certificate Signing Request (PEM Encoded) file path: " + certificateSigningRequestPemEncodedFilePath);
            }

            var certificateConfiguration = (CertificateManagementConfigurationBase)Settings.Deserialize(typeof(CertificateManagementConfigurationBase), certificateWriterJson);
            var writer = CertificateManagementFactory.CreateWriter(certificateConfiguration);

            var encryptingCertificateStoreNameEnum = encryptingCertificateStoreName == null
                                                         ? CertificateLocator.DefaultCertificateStoreName
                                                         : (StoreName)Enum.Parse(typeof(StoreName), encryptingCertificateStoreName);
            var encryptingCertificateStoreLocationEnum = encryptingCertificateStoreLocation == null
                                                             ? CertificateLocator.DefaultCertificateStoreLocation
                                                             : (StoreLocation)Enum.Parse(typeof(StoreLocation), encryptingCertificateStoreLocation);

            var encryptingCertificateLocator = new CertificateLocator(
                encryptingCertificateThumbprint,
                encryptingCertificateIsValid,
                encryptingCertificateStoreNameEnum,
                encryptingCertificateStoreLocationEnum);

            var bytes = File.ReadAllBytes(pfxFilePath);
            var certificateSigningRequestPemEncoded = certificateSigningRequestPemEncodedFilePath == null
                                                          ? null
                                                          : File.ReadAllText(certificateSigningRequestPemEncodedFilePath);

            var certToLoad = CertificateManagementFactory.BuildCertificateDescriptionWithClearPfxPayload(name, bytes, clearTextPassword, certificateSigningRequestPemEncoded);

            var cert = certToLoad.ToEncryptedVersion(encryptingCertificateLocator);

            Run.TaskUntilCompletion(writer.PersistCertificateAsync(cert));
        }

        /// <summary>
        /// Creates a new environment.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="configFilePath">XML Serialized <see cref="ConfigEnvironment "/> describing assets to create.</param>
        /// <param name="outputArcologyPath">File path to create a file based arcology at.</param>
        /// <param name="computingPlatformKeyFilePath">Key file from computing provider for creating assets.</param>
        /// <param name="environmentCertificateFilePath">Certificate file to use for each machine.</param>
        /// <param name="environmentCertificatePassword">Password for environment certificate file.</param>
        /// <param name="deploymentCertificateFilePath">Certificate file to use for encrypting sensitive data.</param>
        /// <param name="deploymentCertificatePassword">Password for the deployment certificate file.</param>
        /// <param name="windowsSkuSearchPatternMapJson">Map of <see cref="WindowsSku" /> to search pattern to find appropriate instance template.</param>
        /// <param name="rootDomainHostingIdMapJson">Map of root domain to root hosting ID for computing platform.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Optional environment name that will set the <see cref="Its.Configuration" /> precedence instead of the default which is reading the App.Config value.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = "All disposables are disposed, not sure why it's upset about the Creator.CreateEnvironment call.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "This is fine.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Sku", Justification = "Spelling/name is correct.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "create", Description = "Creates a new environment.")]
        public static void CreateEnvironment(
                [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
                [Required] [Aliases("file")] [Description("XML Serialized ConfigEnvironment describing assets to create.")] string configFilePath,
                [Required] [Aliases("path")] [Description("File path to create a file based arcology at.")] string outputArcologyPath,
                [Required] [Aliases("")] [Description("ey file from computing provider for creating assets.")] string computingPlatformKeyFilePath,
                [Required] [Aliases("")] [Description("Certificate to encrypt the key.")] string environmentCertificateFilePath,
                [Required] [Aliases("")] [Description("Certificate file to use for each machine.")] string environmentCertificatePassword,
                [Required] [Aliases("")] [Description("Password for environment certificate file.")] string deploymentCertificateFilePath,
                [Required] [Aliases("")] [Description("Password for the deployment certificate file.")] string deploymentCertificatePassword,
                [Required] [Aliases("")] [Description("Map of WindowsSku to search pattern to find appropriate instance template.")] string windowsSkuSearchPatternMapJson,
                [Required] [Aliases("")] [Description("Map of root domain to root hosting ID for computing platform.")] string rootDomainHostingIdMapJson,
                [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
                [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment)
        {
            CommonSetup(debug, environment);

            new { credentialsJson }.Must().NotBeNullNorWhiteSpace();
            new { configFilePath }.Must().NotBeNullNorWhiteSpace();
            new { outputArcologyPath }.Must().NotBeNullNorWhiteSpace();
            new { computingPlatformKeyFilePath }.Must().NotBeNullNorWhiteSpace();
            new { environmentCertificateFilePath }.Must().NotBeNullNorWhiteSpace();
            new { environmentCertificatePassword }.Must().NotBeNullNorWhiteSpace();
            new { deploymentCertificateFilePath }.Must().NotBeNullNorWhiteSpace();
            new { deploymentCertificatePassword }.Must().NotBeNullNorWhiteSpace();
            new { windowsSkuSearchPatternMapJson }.Must().NotBeNullNorWhiteSpace();
            new { rootDomainHostingIdMapJson }.Must().NotBeNullNorWhiteSpace();

            var serializer = SerializerFactory.Instance.BuildSerializer(Config.ConfigFileSerializationDescription);

            var outputConfigFilePath = Path.Combine(outputArcologyPath, Path.ChangeExtension(configFilePath, ".Created.xml"));
            if (File.Exists(outputConfigFilePath))
            {
                var backupOutputConfigFilePath = Path.ChangeExtension(
                    outputConfigFilePath,
                    Invariant($".BackedUpOn{DateTime.UtcNow.ToString("yyyy-MM-dd--HH-mm-ss", CultureInfo.InvariantCulture)}Z.xml"));
                if (File.Exists(backupOutputConfigFilePath))
                {
                    throw new ArgumentException(Invariant($"Unexpected file present on disk: {backupOutputConfigFilePath}"));
                }

                File.Move(outputConfigFilePath, backupOutputConfigFilePath);
            }

            var environmentCertificateBytes = File.ReadAllBytes(environmentCertificateFilePath);
            var environmentCertificateChain = CertHelper.ExtractCryptographicObjectsFromPfxFile(environmentCertificateBytes, environmentCertificatePassword);
            var environmentCertificate = environmentCertificateChain.CertificateChain.GetEndUserCertFromCertChain();

            var deploymentCertificateBytes = File.ReadAllBytes(deploymentCertificateFilePath);
            var deploymentCertificateChain = CertHelper.ExtractCryptographicObjectsFromPfxFile(deploymentCertificateBytes, deploymentCertificatePassword);
            var deploymentCertificate = deploymentCertificateChain.CertificateChain.GetEndUserCertFromCertChain();
            var encryptingCertificateLocator = new CertificateLocator(deploymentCertificate.GetThumbprint(), false);

            // key text from Amazon does not actually work with the API out of the box...
            var keyName = Path.GetFileNameWithoutExtension(computingPlatformKeyFilePath);
            var keyText = File.ReadAllText(computingPlatformKeyFilePath);
            var keyHeader = "-----BEGIN RSA PRIVATE KEY-----";
            var keyFooter = "-----END RSA PRIVATE KEY-----";
            var cleanKeyText = Invariant(
                $"{keyHeader}{Environment.NewLine}{keyText.Replace(keyHeader, string.Empty).Replace(keyFooter, string.Empty).Replace(Environment.NewLine, string.Empty)}{Environment.NewLine}{keyFooter}");
            var encryptedKey = Encryptor.Encrypt(cleanKeyText, encryptingCertificateLocator);

            var rootDomainHostingIdMap = serializer.Deserialize<Dictionary<string, string>>(rootDomainHostingIdMapJson);
            var windowsSkuSearchPatternMap = serializer.Deserialize<Dictionary<WindowsSku, string>>(windowsSkuSearchPatternMapJson);

            var configFileXml = File.ReadAllText(configFilePath);
            var xmlSerializer = new XmlSerializer(typeof(ConfigEnvironment));
            ConfigEnvironment configuration;
            using (var stringReader = new StringReader(configFileXml))
            {
                configuration = (ConfigEnvironment)xmlSerializer.Deserialize(stringReader);
            }

            if (configuration.Vpcs.Length > 1)
            {
                throw new ArgumentException("Cannot create more than one VPC for use with an arcology.");
            }

            void UpdateOutputConfigFile(ConfigEnvironment updatedEnvironment)
            {
                using (var stringWriter = new StringWriter(CultureInfo.InvariantCulture))
                {
                    xmlSerializer.Serialize(stringWriter, updatedEnvironment);
                    File.WriteAllText(outputConfigFilePath, stringWriter.ToString());
                }
            }

            var credentials = serializer.Deserialize<CredentialContainer>(credentialsJson);
            var populatedEnvironment = Run.TaskUntilCompletion(Creator.CreateEnvironment(credentials, configuration, UpdateOutputConfigFile, TimeSpan.FromMinutes(10)));

            var vpc = populatedEnvironment.Vpcs.Single();

            var computingContainers = vpc.Subnets.Where(
                _ => _.Name.ToUpperInvariant().Contains(InstanceAccessibility.Public.ToString().ToUpperInvariant())
                     || _.Name.ToUpperInvariant().Contains(InstanceAccessibility.Private.ToString().ToUpperInvariant())
                     || _.Name.ToUpperInvariant().Contains("VPN")).Select(
                subnet =>
                {
                    var routeTable = vpc.RouteTables.Single(_ => _.Name.Equals(subnet.RouteTableRef, StringComparison.CurrentCultureIgnoreCase));
                    var accessiblity =
                        routeTable.Routes.Any(
                            route => populatedEnvironment.InternetGateways.Any(
                                gateway => route.TargetRef.Equals(gateway.Name, StringComparison.CurrentCultureIgnoreCase)))
                            ? (subnet.Name.ToUpperInvariant().Contains("VPN") ? InstanceAccessibility.Tunnel : InstanceAccessibility.Public)
                            : InstanceAccessibility.Private;

                    var securityGroup = vpc.SecurityGroups.Single();

                    var container = new ComputingContainerDescription
                    {
                        Cidr = subnet.Cidr,
                        ContainerLocation = subnet.AvailabilityZone,
                        ContainerId = subnet.SubnetId,
                        InstanceAccessibility = accessiblity,
                        SecurityGroupId = securityGroup.SecurityGroupId,
                        StartIpsAfter = 10,
                        EncryptingCertificateLocator = encryptingCertificateLocator,
                        KeyName = keyName,
                        EncryptedPrivateKey = encryptedKey,
                    };

                    return container;
                }).ToList();

            var outputConfigText = File.ReadAllText(outputConfigFilePath);
            var arcologyInfo = new ArcologyInfo
                                   {
                                       Location = populatedEnvironment.RegionName,
                                       SerializedEnvironmentSpecification = outputConfigText,
                                       ComputingContainers = computingContainers,
                                       RootDomainHostingIdMap = rootDomainHostingIdMap,
                                       WindowsSkuSearchPatternMap = windowsSkuSearchPatternMap,
                                   };

            if (!Directory.Exists(outputArcologyPath))
            {
                Directory.CreateDirectory(outputArcologyPath);
            }

            using (var newFileArcology = new RootFolderEnvironmentFolderInstanceFileTracker(outputArcologyPath))
            {
                Run.TaskUntilCompletion(newFileArcology.Create(environment, arcologyInfo));
            }

            var certificatesJsonFilePath = Path.Combine(outputArcologyPath, Invariant($"{environment}.Certificates.json"));
            CertificateWriterToFile.Create(certificatesJsonFilePath);

            var certificateWriter = new CertificateWriterToFile(certificatesJsonFilePath);
            var environmentCertToStore = new CertificateDescriptionWithClearPfxPayload(
                Path.GetFileNameWithoutExtension(environmentCertificateFilePath),
                environmentCertificate.GetThumbprint(),
                environmentCertificate.GetValidityPeriod(),
                environmentCertificate.GetX509SubjectAttributes().ToDictionary(k => k.Key.ToString(), v => v.Value),
                environmentCertificateBytes,
                environmentCertificatePassword);
            Run.TaskUntilCompletion(certificateWriter.PersistCertificateAsync(environmentCertToStore, encryptingCertificateLocator));

            var deploymentCertToStore = new CertificateDescriptionWithClearPfxPayload(
                Path.GetFileNameWithoutExtension(deploymentCertificateFilePath),
                deploymentCertificate.GetThumbprint(),
                deploymentCertificate.GetValidityPeriod(),
                deploymentCertificate.GetX509SubjectAttributes().ToDictionary(k => k.Key.ToString(), v => v.Value),
                deploymentCertificateBytes,
                deploymentCertificatePassword);
            Run.TaskUntilCompletion(certificateWriter.PersistCertificateAsync(deploymentCertToStore, encryptingCertificateLocator));
        }

        /// <summary>
        /// Destroy an existing environment.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="configFilePath">XML Serialized <see cref="ConfigEnvironment "/> describing assets to destroy.</param>
        /// <param name="debug">A value indicating whether or not to launch the debugger.</param>
        /// <param name="environment">Optional environment name that will set the <see cref="Its.Configuration" /> precedence instead of the default which is reading the App.Config value.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "populatedEnvironment", Justification = "Keeping for visibility and use if necessary.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This is fine.")]
        [Verb(Aliases = "destroy", Description = "Destroy an existing environment.")]
        public static void DestroyEnvironment(
            [Aliases("")] [Required] [Description("Credentials for the computing platform provider to use in JSON.")] string credentialsJson,
            [Required] [Aliases("file")] [Description("Configuration file path describing environment to destroy.")] string configFilePath,
            [Aliases("")] [Description("Launches the debugger.")] [DefaultValue(false)] bool debug,
            [Aliases("env")] [Required] [Description("Sets the Its.Configuration precedence to use specific settings.")] string environment)
        {
            CommonSetup(debug, environment);

            new { credentialsJson }.Must().NotBeNullNorWhiteSpace();
            new { configFilePath }.Must().NotBeNullNorWhiteSpace();

            var serializer = SerializerFactory.Instance.BuildSerializer(Config.ConfigFileSerializationDescription);
            var credentials = serializer.Deserialize<CredentialContainer>(credentialsJson);

            var configFileXml = File.ReadAllText(configFilePath);
            var xmlSerializer = new XmlSerializer(typeof(ConfigEnvironment));
            ConfigEnvironment configuration;
            using (var stringReader = new StringReader(configFileXml))
            {
                configuration = (ConfigEnvironment)xmlSerializer.Deserialize(stringReader);
            }

            if (configuration.Vpcs.Length > 1)
            {
                throw new ArgumentException("Cannot create more than one VPC for use with an arcology.");
            }

            var cidr = configuration.Vpcs.Single().Cidr;
            var instances = Run.TaskUntilCompletion(new List<InstanceWithStatus>().FillFromAwsAsync(configuration.RegionName, credentials));

            // MUST filter by terminated first because AWS will return null IP addresses which will through on the next filter step...
            var nonTerminatedInstances = instances.Where(_ => _.InstanceStatus.InstanceState != Naos.AWS.Domain.InstanceState.Terminated)
                .Where(_ => ArcologyInfo.IsIpAddressInRange(_.PrivateIpAddress, cidr));
            if (nonTerminatedInstances.Any())
            {
                throw new ArgumentException(Invariant($"Cannot destroy an environment with instances! {environment} has {string.Join(",", instances.Select(_ => _.PrivateIpAddress))}.  If this is intended for destruction then first retire each instance."));
            }

            var outputConfigFilePath = Path.ChangeExtension(configFilePath, ".Removed.xml");
            if (File.Exists(outputConfigFilePath))
            {
                var backupOutputConfigFilePath = Path.ChangeExtension(
                    outputConfigFilePath,
                    Invariant($".BackedUpOn{DateTime.UtcNow.ToString("yyyy-MM-dd--HH-mm-ss", CultureInfo.InvariantCulture)}Z.xml"));
                if (File.Exists(backupOutputConfigFilePath))
                {
                    throw new ArgumentException(Invariant($"Unexpected file present on disk: {backupOutputConfigFilePath}"));
                }

                File.Move(outputConfigFilePath, backupOutputConfigFilePath);
            }

            void UpdateOutputConfigFile(ConfigEnvironment updatedEnvironment)
            {
                using (var stringWriter = new StringWriter(CultureInfo.InvariantCulture))
                {
                    xmlSerializer.Serialize(stringWriter, updatedEnvironment);
                    File.WriteAllText(outputConfigFilePath, stringWriter.ToString());
                }
            }

            var populatedEnvironment = Run.TaskUntilCompletion(Destroyer.RemoveEnvironment(credentials, configuration, UpdateOutputConfigFile, TimeSpan.FromMinutes(10)));
        }

        private static void NugetAnnouncementAction(string output, string nugetAnnouncementFilePath)
        {
            if (!string.IsNullOrWhiteSpace(nugetAnnouncementFilePath))
            {
                lock (NugetAnnouncementFileLock)
                {
                    File.AppendAllText(nugetAnnouncementFilePath, output);
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "This might still get used and is a weird situation.")]
        private static void CopyAll(DirectoryInfo source, DirectoryInfo target)
        {
            // https://stackoverflow.com/questions/58744/copy-the-entire-contents-of-a-directory-in-c-sharp (MSDN solution)
            Directory.CreateDirectory(target.FullName);

            // Copy each file into the new directory.
            foreach (var fi in source.GetFiles())
            {
                fi.CopyTo(Path.Combine(target.FullName, fi.Name), true);
            }

            // Copy each subdirectory using recursion.
            foreach (var sourceSubDir in source.GetDirectories())
            {
                var nextTargetSubDir = target.CreateSubdirectory(sourceSubDir.Name);
                CopyAll(sourceSubDir, nextTargetSubDir);
            }
        }
    }
}